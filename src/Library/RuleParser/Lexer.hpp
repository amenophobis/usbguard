/* -*- C++ -*-   vim: set syntax=cpp:
 * CONTENT: 
 *
 * (1) Includes for required standard headers.
 * (2) Definitions of options and settings for the particular application.
 * (3) #include <quex/code_base/definitions> for default settings.
 * (4) Lexical Analyzer class Lexer and its memento class.
 * (5) Constructor and init core of Lexer.
 * (6) Memento pack and unpack functions.
 *
 * File content generated by Quex 0.65.10.
 *
 * (C) 2005-2012 Frank-Rene Schaefer
 * ABSOLUTELY NO WARRANTY                                                      */
#ifndef __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____LEXER
#define __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____LEXER

#ifdef      __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
    /* In case that multiple lexical analyzers are used the same header
     * files are compiled with a different setting of the macros. The
     * undef of the include guards happens in the following file.              */
#   ifdef   __QUEX_SIGNAL_DEFINED_LEXER_IN_NAMESPACE___QUEX__
#      error "More than one lexical analyzer have been generated in the same name space. Read documentation on command line option '-o'."
#   endif
#   ifndef  QUEX_OPTION_MULTI
#      error "Multiple lexical analyzers detected. QUEX_OPTION_MULTI must be defined and 'quex/code_base/multi.i' must be included in one single file!"
#   endif
#   include <quex/code_base/include-guard-undef>
#   include <quex/code_base/analyzer/member/token-sending-undef.i>
#   undef   __QUEX_INCLUDE_GUARD__ANALYZER__CONFIGURATION____QUEX____LEXER
#else
#   define  __QUEX_INCLUDE_INDICATOR__ANALYZER__MAIN
#endif
#define     __QUEX_SIGNAL_DEFINED_LEXER_IN_NAMESPACE___QUEX__

#include "Lexer-configuration.hpp"

#include <quex/code_base/definitions>

QUEX_NAMESPACE_MAIN_OPEN 
    struct QUEX_NAME(Engine_tag);
    struct QUEX_NAME(Memento_tag);
    
    class  QUEX_TYPE0_ANALYZER;    /* Lexer */
    typedef __QUEX_TYPE_ANALYZER_RETURN_VALUE  (*QUEX_NAME(AnalyzerFunctionP))(QUEX_TYPE_ANALYZER*);
QUEX_NAMESPACE_MAIN_CLOSE

/* Token Class Declaration must preceed the user's header, so that the user
 * can refer to it at ease.                                                    */
QUEX_NAMESPACE_TOKEN_OPEN
    class  QUEX_TYPE0_TOKEN;
QUEX_NAMESPACE_TOKEN_CLOSE

/* START: User defined header content _________________________________________
 *        Must come before token class definition, since the token class 
 *        might rely on contents of the header.                                */

#   line 21 "Lexer.qx"

//
// Copyright (C) 2015 Red Hat, Inc.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
// Authors: Daniel Kopecek <dkopecek@redhat.com>
//
#include "Common/Utility.hpp"


#   line 82 "Lexer.hpp"


/* END: _______________________________________________________________________*/

#if defined(__QUEX_OPTION_CONVERTER_HELPER)
#   include "quex/code_base/converter_helper/from-unicode-buffer"
#else
#   include "quex/code_base/converter_helper/from-unicode-buffer"
#endif
#include <quex/code_base/analyzer/headers>

#include "Parser.h"
#include "Lexer-token.hpp"

QUEX_NAMESPACE_MAIN_OPEN 

enum {
    QUEX_NAME(ModeID_PQ_STRING_READER) = 0,
    QUEX_NAME(ModeID_RULE) = 1,
    QUEX_NAME(ModeID_DQ_STRING_READER) = 2
};

        extern QUEX_NAME(Mode)  QUEX_NAME(PQ_STRING_READER);
        extern QUEX_NAME(Mode)  QUEX_NAME(RULE);
        extern QUEX_NAME(Mode)  QUEX_NAME(DQ_STRING_READER);


extern     __QUEX_TYPE_ANALYZER_RETURN_VALUE QUEX_NAME(PQ_STRING_READER_analyzer_function)(QUEX_TYPE_ANALYZER*);
extern     void QUEX_NAME(PQ_STRING_READER_on_entry)(QUEX_TYPE_ANALYZER*, const QUEX_NAME(Mode)*);
extern     void QUEX_NAME(PQ_STRING_READER_on_exit)(QUEX_TYPE_ANALYZER*, const QUEX_NAME(Mode)*);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern     bool QUEX_NAME(PQ_STRING_READER_has_base)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(PQ_STRING_READER_has_entry_from)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(PQ_STRING_READER_has_exit_to)(const QUEX_NAME(Mode)*);
#endif
extern     __QUEX_TYPE_ANALYZER_RETURN_VALUE QUEX_NAME(RULE_analyzer_function)(QUEX_TYPE_ANALYZER*);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern     bool QUEX_NAME(RULE_has_base)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(RULE_has_entry_from)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(RULE_has_exit_to)(const QUEX_NAME(Mode)*);
#endif
extern     __QUEX_TYPE_ANALYZER_RETURN_VALUE QUEX_NAME(DQ_STRING_READER_analyzer_function)(QUEX_TYPE_ANALYZER*);
extern     void QUEX_NAME(DQ_STRING_READER_on_entry)(QUEX_TYPE_ANALYZER*, const QUEX_NAME(Mode)*);
extern     void QUEX_NAME(DQ_STRING_READER_on_exit)(QUEX_TYPE_ANALYZER*, const QUEX_NAME(Mode)*);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
extern     bool QUEX_NAME(DQ_STRING_READER_has_base)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(DQ_STRING_READER_has_entry_from)(const QUEX_NAME(Mode)*);
extern     bool QUEX_NAME(DQ_STRING_READER_has_exit_to)(const QUEX_NAME(Mode)*);
#endif



typedef struct QUEX_SETTING_USER_CLASS_DECLARATION_EPILOG QUEX_NAME(Memento_tag) {
#   include <quex/code_base/analyzer/EngineMemento_body>

    QUEX_NAME(Memento_tag)()  {}  /* Con- and Destruction necessary to trigger */
    ~QUEX_NAME(Memento_tag)() {}  /* con- and destruction of user members.     */

/* START: User's memento extentions ___________________________________________*/

/* END: _______________________________________________________________________*/
} QUEX_NAME(Memento);

QUEX_NAMESPACE_MAIN_CLOSE 

QUEX_NAMESPACE_MAIN_OPEN 

extern QUEX_NAME(Mode)*   (QUEX_NAME(mode_db)[__QUEX_SETTING_MAX_MODE_CLASS_N]);  

class QUEX_SETTING_USER_CLASS_DECLARATION_EPILOG Lexer {
public:
#   include <quex/code_base/analyzer/Engine_body>

    /* DISABLED */ Lexer(const Lexer&);
public:
    typedef QUEX_TYPE_TOKEN      token_type;
    typedef QUEX_TYPE_TOKEN_ID   token_id_type;
    typedef QUEX_TYPE_CHARACTER  char_type;

    /*_________________________________________________________________________
     * Constructor:
     *
     * 'from' functions are provided so that explicit constructor calls 
     * can be done without placement ::new or sophisticated C++11 features.  */
    void    from(const char*  Filename, const char*  CodecName = 0x0);
    void    from(std::FILE* fh, const char*  CodecName = 0x0, bool BinaryModeF=false);
    void    from(std::istream* istream_p, const char*  CodecName = 0x0);
#   if defined(__QUEX_OPTION_WCHAR_T)
    void    from(std::wistream* istream_p, const char*  CodecName = 0x0);
#   endif
    void    from(QUEX_NAME(ByteLoader)* byte_loader, const char*  CodecName = 0x0);
    void    from(QUEX_NAME(BufferFiller)* filler);
    void    from(QUEX_TYPE_CHARACTER* BufferMemoryBegin, 
                 size_t               BufferMemorySize,
                 QUEX_TYPE_CHARACTER* BufferEndOfContentP = 0x0);
#   if defined(__QUEX_OPTION_UNIT_TEST)
    template <class UnderlyingStreamT> 
    void    from_StrangeStream(quex::StrangeStream<UnderlyingStreamT>*  istream_p, 
                               const char*                              CodecName = 0x0);
#   endif

    /* Level (1) ______________________________________________________________
     *                                                                       */
    Lexer(const char*  Filename, const char*  CodecName = 0x0)
          { from(Filename, CodecName); }
    Lexer(const std::string&  Filename, const char*  CodecName = 0x0)
          { from(Filename.c_str(), CodecName); }

    /* Level (2) ______________________________________________________________
     *                                                                       */
    Lexer(std::FILE*     fh, const char*  CodecName = 0x0, bool BinaryModeF=false)
          { from(fh, CodecName, BinaryModeF); }
    Lexer(std::istream*  istream_p, const char*  CodecName = 0x0)
          { from(istream_p, CodecName); }
#   if defined(__QUEX_OPTION_WCHAR_T)
    Lexer(std::wistream* istream_p, const char*  CodecName = 0x0)
          { from(istream_p, CodecName); }
#   endif
#   if defined(__QUEX_OPTION_UNIT_TEST)
    template <class UnderlyingStreamT>
    Lexer(quex::StrangeStream<UnderlyingStreamT>*  istream_p, 
          const char*                              CodecName = 0x0)
          { from_StrangeStream(istream_p, CodecName); }
#   endif

    /* Level (3) ______________________________________________________________
     *                                                                       */
    Lexer(QUEX_NAME(ByteLoader)*  byte_loader, const char*  CodecName = 0x0)
          { from(byte_loader, CodecName); }

    /* Level (4) ______________________________________________________________
     *                                                                       */
    Lexer(QUEX_NAME(BufferFiller)* filler)
          { from(filler); }

    /* Level (5) ______________________________________________________________
     *                                                                       */
    Lexer(QUEX_TYPE_CHARACTER* BufferMemoryBegin, 
          size_t               BufferMemorySize,
          QUEX_TYPE_CHARACTER* BufferEndOfContentP = 0x0)
          { from(BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP); }

    virtual ~Lexer();

    /*_________________________________________________________________________
     * Reset:
     *
     * Level (0) ______________________________________________________________
     *                                                                       */
    void    reset();

    /* Level (1) ______________________________________________________________
     *                                                                       */
    void    reset(const char* FileName, const char*  CodecName = 0x0);
    void    reset(const std::string&  FileName, const char*  CodecName = 0x0)
            { reset(FileName.c_str(), CodecName); }

    /* Level (2) ______________________________________________________________
     *                                                                       */
    void    reset(__QUEX_STD_FILE*  fh, const char*  CodecName = 0x0, bool BinaryModeF=false);
    void    reset(std::istream*     istream_p, const char*  CodecName = 0x0);
#   if defined(__QUEX_OPTION_WCHAR_T)
    void    reset(std::wistream*    istream_p, const char*  CodecName = 0x0);
#   endif
#   if defined(__QUEX_OPTION_UNIT_TEST)
    template <class UnderlyingStreamT>
    void    reset_StrangeStream(quex::StrangeStream<UnderlyingStreamT>*  istream_p, 
                                const char*                              CodecName = 0x0);
#   endif

    /* Level (3) ______________________________________________________________
     *                                                                       */
    void    reset(QUEX_NAME(ByteLoader)*  byte_loader, const char*  CodecName = 0x0);

    /* Level (4) ______________________________________________________________
     *                                                                       */
    void    reset(QUEX_NAME(BufferFiller)*  filler); 

    /* Level (5) ______________________________________________________________
     *                                                                       */
    QUEX_TYPE_CHARACTER*
            reset(QUEX_TYPE_CHARACTER* BufferMemoryBegin, 
                  size_t               BufferMemorySize,
                  QUEX_TYPE_CHARACTER* BufferEndOfContentP);  

#   ifdef QUEX_OPTION_INCLUDE_STACK
    /*_________________________________________________________________________
     * Include:
     *
     * Level (1) ______________________________________________________________
     *                                                                       */
    bool    include_push(const char*  FileName, const char*  CodecName = 0x0);
    bool    include_push(const std::string&  FileName, const char*  CodecName = 0x0)
            { return include_push(FileName.c_str(), CodecName); }

    /* Level (2) ______________________________________________________________
     *                                                                       */
    bool    include_push(const char*       InputName, 
                         __QUEX_STD_FILE*  fh, 
                         const char*       CodecName = 0x0,
                         bool              BinaryModeF = false);
    bool    include_push(const char*       InputName,
                         std::istream*     istream_p, 
                         const char*       CodecName = 0x0);
#   if defined(__QUEX_OPTION_WCHAR_T)
    bool    include_push(const char*    InputName, 
                         std::wistream* istream_p, 
                         const char*    CodecName = 0x0);
#   endif
#   if defined(__QUEX_OPTION_UNIT_TEST)
    template <class UnderlyingStreamT>
    bool    include_push(const char*                              InputName, 
                         quex::StrangeStream<UnderlyingStreamT>*  istream_p, 
                         const char*                              CodecName = 0x0);
#   endif

    /* Level (3) ______________________________________________________________
     *                                                                       */
    bool    include_push(const char*  InputName, 
                         QUEX_NAME(ByteLoader)*  byte_loader, 
                         const char*  CodecName = 0x0);

    /* Level (4) ______________________________________________________________
     *                                                                       */
    bool    include_push(const char*               InputName, 
                         QUEX_NAME(BufferFiller)*  filler); 

    /* Level (5) ______________________________________________________________
     *                                                                       */
    bool    include_push(const char*          InputName, 
                         QUEX_TYPE_CHARACTER* BufferMemoryBegin, 
                         size_t               BufferMemorySize,
                         QUEX_TYPE_CHARACTER* BufferEndOfContentP);  

    bool    include_pop();
    void    include_stack_delete();
    bool    include_detect_recursion(const char* InputName);
#   endif

    QUEX_TYPE_CHARACTER*  lexeme_start_pointer_get();
    void                  input_pointer_set(QUEX_TYPE_CHARACTER*);

    /* -- activate/deactivate byte order reversion (big-/little-endian)      */
    bool                  byte_order_reversion();
    void                  byte_order_reversion_set(bool Value);

    /* NOTE: All calls to receive functions for 'queue' and 'single'
     *       are deliberately chosen to be incompatible! Thus, when 
     *       the user switches the token passing policy, he must re-
     *       think his receive mechanism.                                    */
#   if defined(QUEX_OPTION_TOKEN_POLICY_QUEUE)
    /* (1) Token Queue 
     * 
     *   When using a token queue, the pointer **must** be adapted.
     *   Otherwise, very strange results may occur. Force the user to
     *   provide a pointer that can be adapted by having him specify
     *   the second argument--not only a return value.
     *
     *   Command line option:  --token-policy  queue                         */
    void                receive(QUEX_TYPE_TOKEN**);
#   elif defined(QUEX_OPTION_TOKEN_POLICY_SINGLE)  
    /* (2) Single Token
     * 
     *   When there is only one single token as interface, than the
     *   token id is returned. This enables a minimal setup were the
     *   analyzer may only return a token id and does not work on tokens. 
     *
     *   Command line options: --token-policy  single                        */
    QUEX_TYPE_TOKEN_ID  receive();
#   else
#       error "This section should never be compiled."
#   endif

    /* A pointer to an object of the token queue/object is used in order to
     * make memory management more flexible.  The token queue/token object is
     * heavily used and it should be possible to put it somewhere in memory
     * with other heavily used data so that the cache can take advantage of
     * data locality.                                                        */
    QUEX_TYPE_TOKEN*     token_p();

#   if defined(QUEX_OPTION_TOKEN_POLICY_SINGLE) 
#      if defined(QUEX_OPTION_USER_MANAGED_TOKEN_MEMORY)
       void              token_p_set(QUEX_TYPE_TOKEN*);
       QUEX_TYPE_TOKEN*  token_p_swap(QUEX_TYPE_TOKEN*);
#      endif
#   else
       bool              token_queue_is_empty();
       void              token_queue_remainder_get(QUEX_TYPE_TOKEN** begin, QUEX_TYPE_TOKEN** end);
#      if defined(QUEX_OPTION_USER_MANAGED_TOKEN_MEMORY)
       void              token_queue_get(QUEX_TYPE_TOKEN** begin, size_t* size);
       void              token_queue_set(QUEX_TYPE_TOKEN* Begin, size_t Size);
       void              token_queue_swap(QUEX_TYPE_TOKEN** queue, 
                                            size_t*           size); 
#      endif
#   endif

    //
    // (*) Mode handling
    //
    //     -- modes: read access
    QUEX_NAME(Mode)&      mode();
    int                   mode_id() const;
    const char*           mode_name() const;
    //
    //     -- modes: changing lexical analysis mode
    void                  set_mode_brutally(const int ModeId);
    void                  set_mode_brutally(const QUEX_NAME(Mode)& Mode);
    //                    
    void                  operator<<(const int ModeId);               
    void                  operator<<(/* NOT const*/ QUEX_NAME(Mode)& Mode);  
    //                    
    void                  pop_mode();
    void                  pop_drop_mode();
    void                  push_mode(QUEX_NAME(Mode)& new_mode);
    //                    
    void                  enter_mode(/* NOT const*/ QUEX_NAME(Mode)& TargetMode);
    //
    //     -- map: mode id to mode and vice versa
    QUEX_NAME(Mode)&      map_mode_id_to_mode(const int              ModeID);       
    int                   map_mode_to_mode_id(const QUEX_NAME(Mode)& Mode) const;

#   ifdef  QUEX_OPTION_LINE_NUMBER_COUNTING
    size_t      line_number() const            { return line_number_at_begin(); }
    size_t      line_number_at_begin() const   { return counter._line_number_at_begin; }
    size_t      line_number_at_end() const     { return counter._line_number_at_end; }
    /*          line_number_set(...) defines the column number of the next pattern match. */
    void        line_number_set(size_t Y)      { counter._line_number_at_end = Y; }
#   endif
#   ifdef  QUEX_OPTION_COLUMN_NUMBER_COUNTING
    size_t      column_number() const          { return column_number_at_begin(); }
    size_t      column_number_at_begin() const { return counter._column_number_at_begin; }
    size_t      column_number_at_end() const   { return counter._column_number_at_end; }
    /*          column_number_set(...) defines the column number of the next pattern match. */
    void        column_number_set(size_t X)    { counter._column_number_at_end = X; }
#   endif
#   ifdef   QUEX_OPTION_INDENTATION_TRIGGER
    size_t      indentation()                  { return counter._indentation_stack.back - counter._indentation_stack.front + 1; }
#   endif

    // (*) Version information
    const char* version() const; // created by quex for version/date information

    // (*) Tell/Seek/Move on basis of character index
    size_t  tell();
    void    seek(const size_t);
    void    seek_forward(const size_t);
    void    seek_backward(const size_t);

    void    undo();
    void    undo(size_t DeltaN_Backward);

    void    move_forward(const size_t) { QUEX_ERROR_EXIT("'move_forward()' has been renamed to 'seek_forward()'."); }
    void    move_backward(const size_t){ QUEX_ERROR_EXIT("'move_backward()' has been renamed to 'seek_backward()'."); }

public:

    void    set_callback_on_buffer_content_change(void (*callback)(const QUEX_TYPE_CHARACTER*, 
                                                                   const QUEX_TYPE_CHARACTER*));

public:
    void    print_this();

private:
    // (*) Common for constructor, reset, and include push ___________________________
    void    basic_constructor();
    bool    basic_include_push(const char* InputName, QUEX_NAME(Buffer)* new_buffer_setup); 
    void    basic_reset();

    void    user_constructor();
    bool    user_memento_pack(const char* InputName, QUEX_NAME(Memento)*); 
    void    user_memento_unpack(QUEX_NAME(Memento)*);
    void    user_reset();

    /* (*) All Modes are Friends ___________________________________________________*/
    friend     __QUEX_TYPE_ANALYZER_RETURN_VALUE QUEX_NAME(PQ_STRING_READER_analyzer_function)(QUEX_TYPE_ANALYZER*);
    friend     void QUEX_NAME(PQ_STRING_READER_on_entry)(QUEX_TYPE_ANALYZER*, const QUEX_NAME(Mode)*);
    friend     void QUEX_NAME(PQ_STRING_READER_on_exit)(QUEX_TYPE_ANALYZER*, const QUEX_NAME(Mode)*);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
    friend     bool QUEX_NAME(PQ_STRING_READER_has_base)(const QUEX_NAME(Mode)*);
    friend     bool QUEX_NAME(PQ_STRING_READER_has_entry_from)(const QUEX_NAME(Mode)*);
    friend     bool QUEX_NAME(PQ_STRING_READER_has_exit_to)(const QUEX_NAME(Mode)*);
#endif
    friend     __QUEX_TYPE_ANALYZER_RETURN_VALUE QUEX_NAME(RULE_analyzer_function)(QUEX_TYPE_ANALYZER*);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
    friend     bool QUEX_NAME(RULE_has_base)(const QUEX_NAME(Mode)*);
    friend     bool QUEX_NAME(RULE_has_entry_from)(const QUEX_NAME(Mode)*);
    friend     bool QUEX_NAME(RULE_has_exit_to)(const QUEX_NAME(Mode)*);
#endif
    friend     __QUEX_TYPE_ANALYZER_RETURN_VALUE QUEX_NAME(DQ_STRING_READER_analyzer_function)(QUEX_TYPE_ANALYZER*);
    friend     void QUEX_NAME(DQ_STRING_READER_on_entry)(QUEX_TYPE_ANALYZER*, const QUEX_NAME(Mode)*);
    friend     void QUEX_NAME(DQ_STRING_READER_on_exit)(QUEX_TYPE_ANALYZER*, const QUEX_NAME(Mode)*);
#ifdef QUEX_OPTION_RUNTIME_MODE_TRANSITION_CHECK
    friend     bool QUEX_NAME(DQ_STRING_READER_has_base)(const QUEX_NAME(Mode)*);
    friend     bool QUEX_NAME(DQ_STRING_READER_has_entry_from)(const QUEX_NAME(Mode)*);
    friend     bool QUEX_NAME(DQ_STRING_READER_has_exit_to)(const QUEX_NAME(Mode)*);
#endif

  

public:
#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)this)
/* START: User's class body extensions _____________________________________________*/

/* END: ____________________________________________________________________________*/
#undef  self

public:
    // (*) Token sending happens only via 'self_send*(...)' macros
    void   send(const QUEX_TYPE_TOKEN_ID TokenID)
    { (void)TokenID; QUEX_ERROR_DEPRECATED("Member functions .send()", "macros: self_send*()"); }
    // At least warn those, who still use the old interface ...
    void   get_token() 
    { QUEX_ERROR_DEPRECATED("Member functions .get_token()", ".receive(...)"); }
    void   get_token(QUEX_TYPE_TOKEN*   result_p)  { (void)result_p; get_token(); }
    void   get_token(QUEX_TYPE_TOKEN**  result_pp) { (void)result_pp; get_token(); }
};

QUEX_NAMESPACE_MAIN_CLOSE

QUEX_NAMESPACE_MAIN_OPEN

QUEX_INLINE void
QUEX_MEMBER_FUNCTIONO(user_constructor)
{
    QUEX_MAP_THIS_TO_ME(QUEX_TYPE_ANALYZER) 
    (void)me;

    __quex_assert(QUEX_NAME(mode_db)[QUEX_NAME(ModeID_PQ_STRING_READER)] == &QUEX_NAME(PQ_STRING_READER));
    __quex_assert(QUEX_NAME(mode_db)[QUEX_NAME(ModeID_RULE)]             == &QUEX_NAME(RULE));
    __quex_assert(QUEX_NAME(mode_db)[QUEX_NAME(ModeID_DQ_STRING_READER)] == &QUEX_NAME(DQ_STRING_READER));


#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's constructor extensions _______________________________________*/

/* END: _______________________________________________________________________*/
#undef self
}

QUEX_INLINE void
QUEX_MEMBER_FUNCTIONO(user_reset) 
{
    QUEX_MAP_THIS_TO_ME(QUEX_TYPE_ANALYZER)
    (void)me;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's 'reset' ______________________________________________________*/

/* END: _______________________________________________________________________*/
#undef self
}

#ifdef QUEX_OPTION_INCLUDE_STACK

QUEX_INLINE bool
QUEX_MEMBER_FUNCTIONO2(user_memento_pack, 
                       const char*         InputName, 
                       QUEX_NAME(Memento)* memento) 
{
    QUEX_MAP_THIS_TO_ME(QUEX_TYPE_ANALYZER) 
    (void)me; (void)memento; (void)InputName;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's memento 'pack' _______________________________________________*/

/* END: _______________________________________________________________________*/
#undef self
    return true;
}

QUEX_INLINE void
QUEX_MEMBER_FUNCTIONO1(user_memento_unpack, QUEX_NAME(Memento)*  memento)
{
    QUEX_MAP_THIS_TO_ME(QUEX_TYPE_ANALYZER) 
    (void)me; (void)memento;

#define self  (*(QUEX_TYPE_DERIVED_ANALYZER*)me)
/* START: User's memento 'unpack' _____________________________________________*/

/* END: _______________________________________________________________________*/
#undef self
}
#endif /* QUEX_OPTION_INCLUDE_STACK */

QUEX_NAMESPACE_MAIN_CLOSE

#if defined(__QUEX_OPTION_CONVERTER_HELPER)
#   include "quex/code_base/converter_helper/from-unicode-buffer.i"
#else
#   include "quex/code_base/converter_helper/from-unicode-buffer.i"
#endif
#include <quex/code_base/analyzer/headers.i>




#endif /* __QUEX_INCLUDE_GUARD__ANALYZER__GENERATED____QUEX____LEXER */
